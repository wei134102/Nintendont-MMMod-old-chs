name: Build Nintendont (Windows)

on:
  workflow_dispatch:

jobs:
  build:
    runs-on: windows-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 1
    
    - name: Debug - Check repository structure
      shell: powershell
      run: |
        echo "Current directory structure:" 
        Get-ChildItem -Path . -Recurse | Select-Object FullName | Format-Table -HideTableHeaders
        echo "Contents of tools directory:" 
        Get-ChildItem -Path .\tools -Recurse | Select-Object FullName | Format-Table -HideTableHeaders
    
    - name: Set up dependencies
      shell: powershell
      run: |
        # Create toolchain directory
        echo "Creating C:\devkitPro directory..."
        New-Item -ItemType Directory -Force -Path C:\devkitPro
        
        # Verify files in tools directory
        echo "Verifying files in tools directory..."
        if (!(Test-Path -Path .\tools\devkitARM.7z)) { echo "Error: devkitARM.7z file not found!"; exit 1 }
        if (!(Test-Path -Path .\tools\devkitPPC.7z)) { echo "Error: devkitPPC.7z file not found!"; exit 1 }
        if (!(Test-Path -Path .\tools\libogc.7z)) { echo "Error: libogc.7z file not found!"; exit 1 }
        
        # Extract devkitARM.7z from tools directory to C:\devkitPro
        echo "Extracting devkitARM.7z..."
        7z x -y .\tools\devkitARM.7z -oC:\devkitPro
        if ($LASTEXITCODE -ne 0) { echo "Error: Failed to extract devkitARM.7z!"; exit 1 }
        
        # Extract devkitPPC.7z from tools directory to C:\devkitPro
        # Note: devkitppc-rules is already included in devkitPPC.7z
        echo "Extracting devkitPPC.7z..."  
        7z x -y .\tools\devkitPPC.7z -oC:\devkitPro
        if ($LASTEXITCODE -ne 0) { echo "Error: Failed to extract devkitPPC.7z!"; exit 1 }
        
        # Extract libogc.7z from tools directory to C:\devkitPro
        echo "Extracting libogc.7z..."  
        7z x -y .\tools\libogc.7z -oC:\devkitPro
        if ($LASTEXITCODE -ne 0) { echo "Error: Failed to extract libogc.7z!"; exit 1 }
        
        # Display directory structure after extraction for debugging
        echo "Directory structure of C:\devkitPro after extraction:" 
        Get-ChildItem -Path C:\devkitPro -Recurse | Select-Object FullName | Format-Table -HideTableHeaders

    - name: Check devkitPPC structure and tools
      shell: powershell
      run: |
        # Check for wii_rules file
        echo "Looking for wii_rules file in C:\devkitPro..."
        Get-ChildItem -Path C:\devkitPro -Recurse -Filter "wii_rules" | Select-Object FullName | Format-Table -HideTableHeaders
        
        # Check devkitPPC bin directory for powerpc-eabi-gcc
        echo "Contents of C:\devkitPro\devkitPPC\bin directory:" 
        if (Test-Path -Path 'C:\devkitPro\devkitPPC\bin') {
          Get-ChildItem -Path 'C:\devkitPro\devkitPPC\bin' | Select-Object Name | Format-Table -HideTableHeaders
          # Check specifically for powerpc-eabi-gcc
          if (Test-Path -Path 'C:\devkitPro\devkitPPC\bin\powerpc-eabi-gcc.exe') {
            echo "Found powerpc-eabi-gcc.exe in C:\devkitPro\devkitPPC\bin"
          } else {
            echo "Warning: powerpc-eabi-gcc.exe not found in C:\devkitPro\devkitPPC\bin"
          }
        } else {
          echo "Error: C:\devkitPro\devkitPPC\bin directory not found!"
        }

    - name: Set environment variables
      shell: powershell
      run: |
        # Set environment variables
        echo "DEVKITPRO=C:\devkitPro" | Out-File -FilePath $env:GITHUB_ENV -Append
        echo "DEVKITARM=C:\devkitPro\devkitARM" | Out-File -FilePath $env:GITHUB_ENV -Append
        echo "DEVKITPPC=C:\devkitPro\devkitPPC" | Out-File -FilePath $env:GITHUB_ENV -Append
        
        # Add toolchain bin directories to PATH
        echo "PATH=%PATH%;C:\devkitPro\devkitARM\bin;C:\devkitPro\devkitPPC\bin" | Out-File -FilePath $env:GITHUB_ENV -Append
        
        # Verify environment variables
        echo "Environment variables:" 
        echo "DEVKITPRO=$env:DEVKITPRO"
        echo "DEVKITARM=$env:DEVKITARM"
        echo "DEVKITPPC=$env:DEVKITPPC"
        echo "PATH=$env:PATH"
        
        # Verify toolchain directories
        echo "Verifying toolchain directories..."
        if (!(Test-Path -Path C:\devkitPro\devkitARM)) { echo "Error: devkitARM directory not found!"; exit 1 }
        if (!(Test-Path -Path C:\devkitPro\devkitPPC)) { echo "Error: devkitPPC directory not found!"; exit 1 }
        
        # Display contents of toolchain bin directories
        echo "Contents of devkitARM/bin directory:" 
        if (Test-Path -Path C:\devkitPro\devkitARM\bin) {
          Get-ChildItem -Path C:\devkitPro\devkitARM\bin | Select-Object Name | Format-Table -HideTableHeaders
        }
        echo "Contents of devkitPPC/bin directory:" 
        if (Test-Path -Path 'C:\devkitPro\devkitPPC\bin') {
          Get-ChildItem -Path 'C:\devkitPro\devkitPPC\bin' | Select-Object Name | Format-Table -HideTableHeaders
        }

    - name: Install make tool
      shell: powershell
      run: |
        # Install make tool using chocolatey (available in GitHub Actions Windows runners)
        echo "Installing make tool using chocolatey..."
        try {
          # Check if chocolatey is available
          if (-not (Get-Command 'choco' -ErrorAction SilentlyContinue)) {
            echo "Chocolatey not found, installing..."
            # Check if there's an existing chocolatey folder that might be corrupted
            if (Test-Path -Path 'C:\ProgramData\chocolatey') {
              echo "Found existing chocolatey folder that might be corrupted. Renaming it..."
              Rename-Item -Path 'C:\ProgramData\chocolatey' -NewName 'C:\ProgramData\chocolatey_old' -Force
            }
            Set-ExecutionPolicy Bypass -Scope Process -Force
            [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072
            iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))
          }
          
          # Install make tool
          choco install make --yes --no-progress
          
          # Verify make installation
          echo "Verifying make installation..."
          if (Get-Command 'make' -ErrorAction SilentlyContinue) {
            $makeVersion = make --version
            echo "Make tool installed successfully. Version: $makeVersion"
            # Get make path and persist to GITHUB_ENV for future steps
            $makePath = (Get-Command 'make').Path
            $makeDir = (Get-Item $makePath).Directory.FullName
            echo "Make found at: $makePath"
            echo "PATH=$makeDir;$env:PATH" | Out-File -FilePath $env:GITHUB_ENV -Append
          } else {
            echo "Warning: make command not found in PATH! Trying to locate it..."
            # Look for make in common locations
            $possiblePaths = @(
              "C:\ProgramData\chocolatey\bin\make.exe",
              "C:\tools\bin\make.exe"
            )
            
            foreach ($path in $possiblePaths) {
              if (Test-Path $path) {
                echo "Found make at $path"
                $makeDir = (Get-Item $path).Directory.FullName
                $env:PATH = "$makeDir;$env:PATH"
                # Persist to GITHUB_ENV for future steps
                echo "PATH=$makeDir;$env:PATH" | Out-File -FilePath $env:GITHUB_ENV -Append
                break
              }
            }
            
            # Final verification after path search
            if (-not (Get-Command 'make' -ErrorAction SilentlyContinue)) {
              echo "Error: make tool could not be found even after path search!"
              # List chocolatey installation directory for debugging
              if (Test-Path -Path 'C:\ProgramData\chocolatey') {
                echo "Contents of C:\ProgramData\chocolatey\bin directory:"
                Get-ChildItem -Path 'C:\ProgramData\chocolatey\bin' | Select-Object Name | Format-Table -HideTableHeaders
              }
              exit 1
            }
          }
        } catch {
          echo "Error: Failed to install make tool! Exception: $($_.Exception.Message)"
          exit 1
        }


    - name: Build Nintendont
      shell: powershell
      run: |
        # Display current environment variables
        echo "Environment variables before build:" 
        echo "DEVKITPRO=$env:DEVKITPRO"
        echo "DEVKITARM=$env:DEVKITARM"
        echo "DEVKITPPC=$env:DEVKITPPC"
        echo "PATH=$env:PATH"
        
        # Verify make is in PATH
        echo "Checking for make in PATH..."
        if (-not (Get-Command 'make' -ErrorAction SilentlyContinue)) {
          echo "Warning: make not found in PATH!"
        }
        
        # Additional debugging for devkitPPC and compiler
        echo "Debugging devkitPPC configuration..."
        # Check if wii_rules exists
        if (Test-Path -Path "$env:DEVKITPPC\wii_rules") {
          echo "Found wii_rules at $env:DEVKITPPC\wii_rules"
          # Show first few lines of wii_rules to understand CC variable definition
          Get-Content -Path "$env:DEVKITPPC\wii_rules" -TotalCount 20
        } else {
          echo "Error: wii_rules not found at $env:DEVKITPPC\wii_rules"
          # Search for wii_rules in devkitPPC directory
          $wiiRulesPath = Get-ChildItem -Path $env:DEVKITPPC -Recurse -Filter "wii_rules" | Select-Object -First 1
          if ($wiiRulesPath) {
            echo "Found wii_rules at $($wiiRulesPath.FullName)"
            # Update DEVKITPPC environment variable to match
            echo "Updating DEVKITPPC to $($wiiRulesPath.Directory.FullName)"
            $env:DEVKITPPC = $wiiRulesPath.Directory.FullName
            echo "DEVKITPPC=$env:DEVKITPPC" | Out-File -FilePath $env:GITHUB_ENV -Append
          }
        }
        
        # Check if devkitPPC bin is in PATH
        if ($env:PATH -like "*$env:DEVKITPPC\bin*") {
          echo "devkitPPC\bin is in PATH"
        } else {
          echo "Warning: devkitPPC\bin not in PATH! Adding it..."
          $env:PATH = "$env:DEVKITPPC\bin;$env:PATH"
          echo "PATH=$env:PATH" | Out-File -FilePath $env:GITHUB_ENV -Append
        }
        
        # Check if powerpc-eabi-gcc is available
        if (Get-Command 'powerpc-eabi-gcc' -ErrorAction SilentlyContinue) {
          echo "Found powerpc-eabi-gcc at $(Get-Command 'powerpc-eabi-gcc').Path"
          powerpc-eabi-gcc --version
        } else {
          echo "Error: powerpc-eabi-gcc not found! Searching for it..."
          Get-ChildItem -Path $env:DEVKITPPC -Recurse -Filter "powerpc-eabi-gcc.exe" | Select-Object FullName | Format-Table -HideTableHeaders
        }
        
        # Windows-specific fix: Handle temporary directory issues
        echo "Configuring Windows-compatible temporary directory..."
        # Create a temporary directory in Windows temp folder
        $tempDir = Join-Path $env:TEMP "nintendont_build_$(Get-Random)"
        New-Item -ItemType Directory -Force -Path $tempDir
        echo "Created temporary directory: $tempDir"
        
        # Set environment variable for the temporary directory
        $env:TMPDIR = $tempDir
        echo "TMPDIR=$env:TMPDIR" | Out-File -FilePath $env:GITHUB_ENV -Append
        
        # Create an additional directory structure to simulate the path that's failing
        $simulatedFailedPath = Join-Path $tempDir "tmp.$([Guid]::NewGuid().ToString().Substring(0,8))"
        New-Item -ItemType Directory -Force -Path $simulatedFailedPath
        echo "Created simulated failed path structure: $simulatedFailedPath"
        
        # Add more debugging about the paths being used
        echo "Current environment paths:"
        echo "TEMP=$env:TEMP"
        echo "TMP=$env:TMP"
        echo "TMPDIR=$env:TMPDIR"
        echo "Current working directory: $(Get-Location)"
        
        # Create a physical C:\tmp directory if it doesn't exist
        # This will provide a /tmp path that works in MinGW
        if (!(Test-Path -Path "C:\tmp")) {
          echo "Creating physical directory C:\tmp"
          New-Item -ItemType Directory -Force -Path "C:\tmp"
          # Ensure the directory is writable
          icacls "C:\tmp" /grant Everyone:F /T /Q
        }
        
        # Make sure the temporary directory is writable
        echo "Setting permissions on temporary directory"
        icacls $tempDir /grant Everyone:F /T /Q
        icacls "C:\tmp" /grant Everyone:F /T /Q
        
        # Create a junction (directory link) instead of a symlink, which might work better in GitHub Actions
        try {
          if (Test-Path -Path "C:\tmp") {
            Remove-Item -Path "C:\tmp" -Recurse -Force -ErrorAction SilentlyContinue
          }
          echo "Creating junction C:\tmp -> $tempDir"
          cmd /c mklink /J "C:\tmp" "$tempDir"
        } catch {
          echo "Warning: Could not create junction for /tmp, creating physical directory instead"
          New-Item -ItemType Directory -Force -Path "C:\tmp"
          icacls "C:\tmp" /grant Everyone:F /T /Q
        }
        
        # Additional debug: Show what C:\tmp actually is
        $tmpDirInfo = Get-Item -Path "C:\tmp" -ErrorAction SilentlyContinue
        if ($tmpDirInfo) {
          echo "C:\tmp type: $($tmpDirInfo.GetType().Name)"
          if ($tmpDirInfo.LinkType) {
            echo "C:\tmp symlink target: $($tmpDirInfo.Target)"
          }
          echo "C:\tmp permissions:" 
          icacls "C:\tmp" | Write-Output
          echo "Contents of C:\tmp:"
          Get-ChildItem -Path "C:\tmp" | Format-Table -AutoSize
        }
        
        # Try to find out what bin2o is doing by checking the wii_rules file
        echo "Looking for wii_rules to understand bin2o definition..."
        $wiiRulesPath = Get-ChildItem -Path $env:DEVKITPPC -Recurse -Filter "wii_rules" -ErrorAction SilentlyContinue | Select-Object -First 1
        if ($wiiRulesPath) {
          echo "Found wii_rules at $($wiiRulesPath.FullName)"
          echo "Searching for bin2o definition..."
          Get-Content -Path $wiiRulesPath.FullName -ErrorAction SilentlyContinue | Select-String -Pattern "bin2o" -Context 3,3 | Write-Output
        }
        
        # Execute make command in Windows environment with windows=1 parameter and verbose output
        echo "Compiling with make command, passing windows=1 parameter..."
        try {
          # Use SHELL=cmd.exe to force Windows-style path handling in make
          # Also pass TMPDIR and TEMP environment variables explicitly
          $env:SHELL = "cmd.exe"
          make forced windows=1 VERBOSE=1 TMPDIR=$tempDir TEMP=$tempDir
          if ($LASTEXITCODE -ne 0) {
            echo "Warning: make command returned non-zero exit code!"
            # Additional debugging after failure
            echo "Debug information after failure:"
            echo "Contents of C:\tmp after build attempt:"
            Get-ChildItem -Path "C:\tmp" -Recurse -ErrorAction SilentlyContinue | Format-Table -AutoSize
            exit 1
          }
        } catch {
          echo "Error: make command execution failed! Exception: $($_.Exception.Message)"
          # Additional debugging after exception
          echo "Contents of C:\tmp after exception:"
          Get-ChildItem -Path "C:\tmp" -Recurse -ErrorAction SilentlyContinue | Format-Table -AutoSize
          exit 1
        } finally {
          # Clean up temporary directory
          echo "Cleaning up temporary directory: $tempDir"
          Remove-Item -Path $tempDir -Recurse -Force -ErrorAction SilentlyContinue
          # Leave C:\tmp directory for potential future use
        }
    
    - name: Verify build output
      shell: powershell
      run: |
        # Check if loader directory exists
        echo "Checking loader directory..."
        if (!(Test-Path -Path .\loader)) { echo "Error: loader directory not found!"; exit 1 }
        
        # Display contents of loader directory
        echo "Contents of loader directory:" 
        Get-ChildItem -Path .\loader | Select-Object Name | Format-Table -HideTableHeaders
        
        # Check if loader.dol file was generated
        if (Test-Path -Path .\loader\loader.dol) {
          echo "Build successful, loader.dol file has been generated!"
          Get-ChildItem -Path .\loader\loader.dol | Select-Object FullName, Length | Format-Table
        } else {
          echo "Error: loader.dol file was not generated!"; exit 1
        }
    
    - name: Upload build artifact
      uses: actions/upload-artifact@v4
      with:
        name: nintendont-loader
        path: loader\loader.dol