on:
  workflow_dispatch:

jobs:
  build:
    runs-on: windows-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 1

    - name: Debug - Check repository structure
      shell: powershell
      run: |
        echo "Current directory structure:";
        Get-ChildItem -Path . -Recurse | Select-Object FullName | Format-Table -HideTableHeaders;
        echo "Contents of tools directory:";
        Get-ChildItem -Path .\tools -Recurse | Select-Object FullName | Format-Table -HideTableHeaders;

    - name: Ensure Chocolatey is installed
      shell: powershell
      run: |
        # Check if Chocolatey is already installed
        if (!(Get-Command 'choco' -ErrorAction SilentlyContinue)) {
          echo "Chocolatey not found, installing...";
          # Use the official Chocolatey installation script
          Set-ExecutionPolicy Bypass -Scope Process -Force;
          [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072;
          Invoke-Expression ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'));
          # Verify installation
          if (Get-Command 'choco' -ErrorAction SilentlyContinue) {
            echo "Chocolatey installed successfully.";
          } else {
            echo "Warning: Chocolatey installation may have failed. Proceeding with alternative methods.";
          }
        } else {
          echo "Chocolatey is already installed. Version: $(choco --version)";
        }

    - name: Install make tool
      shell: powershell
      run: |
        # Install make tool using chocolatey (available in GitHub Actions Windows runners)
        echo "Installing make tool using chocolatey..."
        try {
          # Check if chocolatey is available
          if (-not (Get-Command 'choco' -ErrorAction SilentlyContinue)) {
            echo "Chocolatey not found, installing..."
            # Check if there's an existing chocolatey folder that might be corrupted
            if (Test-Path -Path 'C:\ProgramData\chocolatey') {
              echo "Found existing chocolatey folder that might be corrupted. Renaming it..."
              Rename-Item -Path 'C:\ProgramData\chocolatey' -NewName 'C:\ProgramData\chocolatey_old' -Force
            }
            Set-ExecutionPolicy Bypass -Scope Process -Force
            [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072
            iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))
          }
          
          # Install make tool
          choco install make --yes --no-progress
          
          # Verify make installation
          echo "Verifying make installation..."
          if (Get-Command 'make' -ErrorAction SilentlyContinue) {
            $makeVersion = make --version
            echo "Make tool installed successfully. Version: $makeVersion"
            # Get make path and persist to GITHUB_ENV for future steps
            $makePath = (Get-Command 'make').Path
            $makeDir = (Get-Item $makePath).Directory.FullName
            echo "Make found at: $makePath"
            echo "PATH=$makeDir;$env:PATH" | Out-File -FilePath $env:GITHUB_ENV -Append
          } else {
            echo "Warning: make command not found in PATH! Trying to locate it..."
            # Look for make in common locations
            $possiblePaths = @(
              "C:\ProgramData\chocolatey\bin\make.exe",
              "C:\tools\bin\make.exe"
            )
            
            foreach ($path in $possiblePaths) {
              if (Test-Path $path) {
                echo "Found make at $path"
                $makeDir = (Get-Item $path).Directory.FullName
                $env:PATH = "$makeDir;$env:PATH"
                # Persist to GITHUB_ENV for future steps
                echo "PATH=$makeDir;$env:PATH" | Out-File -FilePath $env:GITHUB_ENV -Append
                break
              }
            }
            
            # Final verification after path search
            if (-not (Get-Command 'make' -ErrorAction SilentlyContinue)) {
              echo "Error: make tool could not be found even after path search!"
              # List chocolatey installation directory for debugging
              if (Test-Path -Path 'C:\ProgramData\chocolatey') {
                echo "Contents of C:\ProgramData\chocolatey\bin directory:"
                Get-ChildItem -Path 'C:\ProgramData\chocolatey\bin' | Select-Object Name | Format-Table -HideTableHeaders
              }
              exit 1
            }
          }
        } catch {
          echo "Error: Failed to install make tool! Exception: $($_.Exception.Message)"
          exit 1
        }

    - name: Set up devkitPro environment from tools directory
      shell: powershell
      run: |
        # Create devkitPro directory
        echo "Creating C:\devkitPro directory...";
        New-Item -ItemType Directory -Force -Path C:\devkitPro;
        
        # Verify files in tools directory
        echo "Verifying files in tools directory...";
        if (!(Test-Path -Path .\tools\devkitARM.7z)) { echo "Error: devkitARM.7z file not found!"; exit 1; }
        if (!(Test-Path -Path .\tools\devkitPPC.7z)) { echo "Error: devkitPPC.7z file not found!"; exit 1; }
        if (!(Test-Path -Path .\tools\libogc.7z)) { echo "Error: libogc.7z file not found!"; exit 1; }
        
        # Extract devkitARM.7z from tools directory to C:\devkitPro
        echo "Extracting devkitARM.7z...";
        7z x -y .\tools\devkitARM.7z -oC:\devkitPro;
        if ($LASTEXITCODE -ne 0) { echo "Error: Failed to extract devkitARM.7z!"; exit 1; }
        
        # Extract devkitPPC.7z from tools directory to C:\devkitPro
        echo "Extracting devkitPPC.7z...";
        7z x -y .\tools\devkitPPC.7z -oC:\devkitPro;
        if ($LASTEXITCODE -ne 0) { echo "Error: Failed to extract devkitPPC.7z!"; exit 1; }
        
        # Extract libogc.7z from tools directory to C:\devkitPro
        echo "Extracting libogc.7z...";
        7z x -y .\tools\libogc.7z -oC:\devkitPro;
        if ($LASTEXITCODE -ne 0) { echo "Error: Failed to extract libogc.7z!"; exit 1; }
        
        # Display directory structure after extraction for debugging
        echo "Directory structure of C:\devkitPro after extraction:";
        Get-ChildItem -Path C:\devkitPro -Recurse | Select-Object FullName | Format-Table -HideTableHeaders;

    - name: Set environment variables
      shell: powershell
      run: |
        # Set environment variables
        "DEVKITPRO=C:\devkitPro" | Out-File -FilePath $env:GITHUB_ENV -Append
        "DEVKITARM=C:\devkitPro\devkitARM" | Out-File -FilePath $env:GITHUB_ENV -Append
        "DEVKITPPC=C:\devkitPro\devkitPPC" | Out-File -FilePath $env:GITHUB_ENV -Append
        
        # Set MAKE environment variable to point to installed make tool
        # This ensures make can be found during the build process
        if (Get-Command 'make' -ErrorAction SilentlyContinue) {
          $makePath = (Get-Command 'make').Path
          "MAKE=$makePath" | Out-File -FilePath $env:GITHUB_ENV -Append
          Write-Host "MAKE tool path set to: $makePath"
        }
        
        # Add toolchain bin directories to PATH
        # Specifically add mingw64 bin path to ensure make tool can be found
        "PATH=%PATH%;C:\mingw64\bin;C:\devkitPro\devkitARM\bin;C:\devkitPro\devkitPPC\bin" | Out-File -FilePath $env:GITHUB_ENV -Append
        
        # Verify environment variables
        Write-Host "Environment variables set:"
        Write-Host "DEVKITPRO=$env:DEVKITPRO"
        Write-Host "DEVKITARM=$env:DEVKITARM"
        Write-Host "DEVKITPPC=$env:DEVKITPPC"
        if (Test-Path env:MAKE) { Write-Host "MAKE=$env:MAKE" }

    # - name: Configure temporary directory
    #   shell: powershell
    #   run: |
    #     # Windows-specific fix: Handle temporary directory issues
    #     echo "Configuring Windows-compatible temporary directory...";
    #     # Create a temporary directory in Windows temp folder
    #     $tempDir = Join-Path $env:TEMP "nintendont_build_$(Get-Random)";
    #     New-Item -ItemType Directory -Force -Path $tempDir;
    #     echo "Created temporary directory: $tempDir";
        
    #     # 设置TMP环境变量非常重要，它为构建过程提供了一个稳定的临时目录路径
    #     # TMP环境变量会被makefile和编译工具使用，解决Windows路径长度限制和权限问题
    #     echo "设置TMP和TMPDIR环境变量，这对构建过程至关重要...";
    #     $env:TMP = $tempDir;
    #     $env:TMPDIR = $tempDir;
    #     echo "TMP=$env:TMP" | Out-File -FilePath $env:GITHUB_ENV -Append;
    #     echo "TMPDIR=$env:TMPDIR" | Out-File -FilePath $env:GITHUB_ENV -Append;
        
    #     # Create a physical C:\tmp directory if it doesn't exist
    #     if (!(Test-Path -Path "C:\tmp")) {
    #       echo "Creating physical directory C:\tmp";
    #       try {
    #         New-Item -ItemType Directory -Force -Path "C:\tmp";
    #         # 移除对icacls命令的依赖，改用PowerShell的Set-Acl cmdlet尝试设置权限
    #         try {
    #           $acl = Get-Acl "C:\tmp";
    #           $rule = New-Object System.Security.AccessControl.FileSystemAccessRule("Everyone", "FullControl", "ContainerInherit,ObjectInherit", "None", "Allow");
    #           $acl.SetAccessRule($rule);
    #           Set-Acl "C:\tmp" $acl;
    #           echo "Successfully set permissions for C:\tmp using PowerShell";
    #         } catch {
    #           echo "Warning: Failed to set permissions for C:\tmp. Continuing with default permissions. Error: $($_.Exception.Message)";
    #         }
    #       } catch {
    #         echo "Warning: Failed to create C:\tmp directory. Error: $($_.Exception.Message)";
    #       }
    #     }

    - name: Build Nintendont
      shell: powershell
      run: |
        # Display current environment variables
        Write-Host "Environment variables before build:";
        Write-Host "DEVKITPRO=$env:DEVKITPRO";
        Write-Host "DEVKITARM=$env:DEVKITARM";
        Write-Host "DEVKITPPC=$env:DEVKITPPC";
        Write-Host "PATH=$env:PATH";
        Write-Host "TMP=$env:TMP";
        Write-Host "TMPDIR=$env:TMPDIR";
        if (Test-Path env:MAKE) { Write-Host "MAKE=$env:MAKE" }
        
        # Execute make command in Windows environment with windows=1 parameter
        Write-Host "Compiling with make command...";
        try {
          # Use SHELL=cmd.exe to force Windows-style path handling in make
          $env:SHELL = "cmd.exe";
          
          # First try to use MAKE environment variable if set
          if ((Test-Path env:MAKE) -and (Test-Path $env:MAKE)) {
            Write-Host "Using make from MAKE environment variable: $env:MAKE";
            & $env:MAKE forced windows=1 VERBOSE=1;
          } 
          # Then check for make in PATH
          elseif (Get-Command 'make' -ErrorAction SilentlyContinue) {
            $makePath = (Get-Command 'make').Path
            Write-Host "Using make from PATH: $makePath";
            make forced windows=1 VERBOSE=1;
          }
          # Finally try to find make in devkitPro
          else {
            $devkitMake = Join-Path $env:DEVKITPRO "msys\usr\bin\make.exe";
            if (Test-Path -Path $devkitMake) {
              Write-Host "Using make from devkitPro: $devkitMake";
              & $devkitMake forced windows=1 VERBOSE=1;
            } else {
              Write-Host "Error: make tool could not be found!";
              exit 1;
            }
          }
          if ($LASTEXITCODE -ne 0) {
            Write-Host "Error: Build failed!";
            exit 1;
          }
        } catch {
          Write-Host "Error: $($_.Exception.Message)";
          exit 1;
        }

    - name: Verify build output
      shell: powershell
      run: |
        # Check if loader directory exists
        echo "Checking loader directory...";
        if (!(Test-Path -Path .\loader)) { echo "Error: loader directory not found!"; exit 1; }
        
        # Check if loader.dol file was generated
        if (Test-Path -Path .\loader\loader.dol) {
          echo "Build successful, loader.dol file has been generated!";
          Get-ChildItem -Path .\loader\loader.dol | Select-Object FullName, Length | Format-Table;
        } else {
          echo "Error: loader.dol file was not generated!"; exit 1;
        }

    - name: Upload build artifact
      uses: actions/upload-artifact@v4
      with:
        name: nintendont-loader
        path: loader\loader.dol